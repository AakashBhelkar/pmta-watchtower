generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum FileType {
  acct
  tran
  bounce
  fbl
  rb
  unknown
}

enum ProcessingStatus {
  pending
  processing
  completed
  error
}

enum Severity {
  low
  medium
  high
  critical
}

enum AlertStatus {
  open
  acknowledged
  resolved
}

enum IncidentStatus {
  open
  resolved
}

enum EntityType {
  domain
  vmta
  user
  job
  ip
}

model File {
  id                String           @id @default(uuid())
  fileName          String
  fileType          FileType
  fileHash          String?          @unique
  fileSize          BigInt?
  uploadTime        DateTime         @default(now())
  processingStatus  ProcessingStatus @default(pending)
  rowCount          Int?
  errorLogs         Json?            @default("[]")
  metadata          Json?            @default("{}")
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  events            Event[]

  @@index([fileType])
  @@index([fileHash])
  @@index([uploadTime])
}

model Event {
  id                String    @id @default(uuid())
  eventType         FileType
  eventTimestamp    DateTime?
  fileId            String?
  file              File?     @relation(fields: [fileId], references: [id], onDelete: Cascade)

  // Core fields
  jobId             String?
  sender            String?
  recipient         String?
  recipientDomain   String?
  vmta              String?
  vmtaPool          String?
  sourceIp          String?
  destinationIp     String?
  envId             String?
  messageId         String?
  customHeader      String?

  // Status fields
  smtpStatus        String?
  bounceCategory    String?
  dsnAction         String?
  dsnDiag           String?

  // Derived fields
  deliveryLatency   Decimal?  @db.Decimal(10, 3)

  // Computed message key for deduplication (COALESCE(messageId, jobId:recipient))
  // Note: This is managed via raw SQL migration as GENERATED ALWAYS AS column
  messageKey        String?

  // Raw data
  rawData           Json?

  createdAt         DateTime  @default(now())

  @@index([eventType])
  @@index([eventTimestamp])
  @@index([jobId])
  @@index([sender])
  @@index([recipientDomain])
  @@index([vmta])
  @@index([fileId])
  @@index([messageId])
  @@index([messageKey])

  // Composite indexes for common query patterns
  @@index([eventType, eventTimestamp])
  @@index([sender, eventType])
  @@index([recipientDomain, eventTimestamp])
  @@index([eventTimestamp, recipientDomain])
  @@index([fileId, eventTimestamp])
  @@index([messageKey, eventType])
}

model AggregateMinute {
  id                String    @id @default(uuid())
  timeBucket        DateTime
  eventType         FileType
  jobId             String?
  sender            String?
  recipientDomain   String?
  vmta              String?
  fileId            String?

  // Event-based counts (legacy, kept for backwards compatibility)
  totalCount        Int       @default(0)
  delivered         Int       @default(0)
  bounced           Int       @default(0)
  deferred          Int       @default(0)
  complaints        Int       @default(0)

  // Message-based counts (deduplicated by messageKey)
  messageAttempts      Int    @default(0)
  deliveredMessages    Int    @default(0)
  bouncedMessages      Int    @default(0)
  complaintMessages    Int    @default(0)

  // Latency aggregation (sum/count pattern for correct math)
  latencySumMs      Float?    @default(0)
  latencyCount      Int       @default(0)

  // Legacy latency fields (deprecated, kept for backwards compatibility)
  avgLatencyMs      Float?
  p95LatencyMs      Float?

  @@unique([timeBucket, eventType, jobId, sender, recipientDomain, vmta, fileId])
  @@index([timeBucket])
  @@index([recipientDomain, timeBucket])
  @@index([jobId, timeBucket])
  @@index([eventType])
  @@index([fileId])
  // Additional compound indexes for analytics queries
  @@index([sender, timeBucket])
  @@index([recipientDomain, eventType, timeBucket])
  @@index([eventType, timeBucket])
}

model RiskScore {
  id                String    @id @default(uuid())
  entityType        EntityType
  entityValue       String
  riskScore         Int       @default(0)
  riskLevel         String    @default("low")
  contributingFactors Json?   @default("{}")
  calculatedAt      DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([entityType, entityValue])
  @@index([riskScore])
}

model Alert {
  id                String      @id @default(uuid())
  alertType         String
  severity          Severity
  entityType        EntityType
  entityValue       String
  timeWindowStart   DateTime
  timeWindowEnd     DateTime
  summary           String
  probableCause     String?
  metrics           Json?       @default("{}")
  status            AlertStatus @default(open)
  incidentId        String?
  incident          Incident?   @relation(fields: [incidentId], references: [id])
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  @@index([entityType, entityValue])
  @@index([status])
  @@index([createdAt])
  // Compound index for duplicate alert checking
  @@index([alertType, entityValue, status, createdAt])
}

model Incident {
  id                String         @id @default(uuid())
  title             String
  severity          Severity
  entityType        EntityType
  entityValue       String
  startTime         DateTime
  endTime           DateTime?
  status            IncidentStatus @default(open)
  summary           String
  rootCause         String?
  alerts            Alert[]
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  @@index([entityType, entityValue])
  @@index([status])
}
